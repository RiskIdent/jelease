package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"

	jira "github.com/andygrunwald/go-jira"
	"github.com/joho/godotenv"
	"github.com/kelseyhightower/envconfig"
)

var (
	jiraClient *jira.Client
	config     Config
)

// Configuration read from environment and .env file.
// Environment takes precedence over the .env file in case of conflicts.
type Config struct {
	// Consider: add split_words tag for nicer readability of env vars
	Port          string `default:"8080"`
	JiraUrl       string `required:"true"`
	JiraUser      string `required:"true"`
	JiraToken     string `required:"true"`
	Project       string `required:"true"`
	DefaultStatus string `required:"true"`
	AddLabels     []string
}

// A new release object unmarshaled from the newreleases.io webhook.
// Some fields omitted for simplicity, check out the documentation at https://newreleases.io/webhooks
type NewRelease struct {
	Provider string `json:"provider"`
	Project  string `json:"project"`
	Version  string `json:"version"`
}

// Generates a Textual summary for the release, intended to be used as the Jira issue summary
func (newRelease NewRelease) IssueSummary() string {
	return fmt.Sprintf("Update %v to version %v", newRelease.Project, newRelease.Version)
}

func NewReleaseToJiraIssue(newRelease NewRelease) jira.Issue {
	labels := append(config.AddLabels, newRelease.Project)
	return jira.Issue{
		Fields: &jira.IssueFields{
			Description: "Update issue generated by newreleases.io",
			Project: jira.Project{
				Key: config.Project,
			},
			Type: jira.IssueType{
				Name: "Task",
			},
			Status: &jira.Status{
				Name: config.DefaultStatus,
			},
			Labels:  labels,
			Summary: newRelease.IssueSummary(),
		},
	}
}

func getRoot(w http.ResponseWriter, r *http.Request) {
	fmt.Printf("got / request\n")
	io.WriteString(w, "Pong!\n")
}

func postWebhook(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
	}
	// parse newreleases.io webhook
	decoder := json.NewDecoder(r.Body)
	var newRelease NewRelease
	err := decoder.Decode(&newRelease)
	if err != nil {
		http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)
		fmt.Fprintf(os.Stderr, "Couldn't decode body to json: %v\n error: %v\n", r.Body, err)
	}
	fmt.Println(newRelease)

	// look for existing update tickets
	previousIssuesQuery := fmt.Sprintf("status = \"%v\" and labels = \"%v\"", config.DefaultStatus, newRelease.Project)

	previousIssues, resp, err := jiraClient.Issue.Search(previousIssuesQuery, &jira.SearchOptions{})
	if err != nil {
		fmt.Println(err.Error())
		body, _ := ioutil.ReadAll(resp.Body)
		fmt.Printf("Error response from Jira when searching previous issues: %+v\n", string(body))
		http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		return
	}

	if len(previousIssues) == 0 {
		// no previous issues, create new jira issue
		i := NewReleaseToJiraIssue(newRelease)
		newIssue, response, err := jiraClient.Issue.Create(&i)
		if err != nil {
			fmt.Println(err.Error())
			body, _ := ioutil.ReadAll(response.Body)
			fmt.Printf("Error response from Jira when creating issue: %+v\n", string(body))
			http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		}
		fmt.Printf("Created issue %v\n", newIssue.ID)
		return
	}

	// This seems hacky, but is taken from the official examples
	// https://github.com/andygrunwald/go-jira/blob/47d27a76e84da43f6e27e1cd0f930e6763dc79d7/examples/addlabel/main.go
	// There is also a jiraClient.Issue.Update() method, but it panics and does not provide a usage example
	type summaryUpdate struct {
		Set string `json:"set" structs:"set"`
	}
	type issueUpdate struct {
		Summary []summaryUpdate `json:"summary" structs:"summary"`
	}

	for _, previousIssue := range previousIssues {
		previousSummary := previousIssue.Fields.Summary

		updates := map[string]interface{}{
			"update": issueUpdate{
				Summary: []summaryUpdate{
					{Set: newRelease.IssueSummary()},
				},
			},
		}

		resp, err = jiraClient.Issue.UpdateIssue(previousIssue.ID, updates)
		if err != nil {
			fmt.Println(err.Error())
			body, _ := ioutil.ReadAll(resp.Body)
			fmt.Printf("Error response from Jira when updating issue: %+v\n", string(body))
			http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		}

		fmt.Printf("Updated issue summary from '%v' to '%v'", previousSummary, newRelease.IssueSummary())
	}
}

func main() {
	// configuration setup
	err := godotenv.Load()
	if err != nil {
		fmt.Println("No .env file found.")
	}

	err = envconfig.Process("jelease", &config)
	if err != nil {
		log.Fatal(err.Error())
	}

	fmt.Printf("Jira URL: %v\n", config.JiraUrl)
	tp := jira.BasicAuthTransport{
		Username: config.JiraUser,
		Password: config.JiraToken,
	}
	jiraClient, err = jira.NewClient(tp.Client(), config.JiraUrl)
	if err != nil {
		panic(err)
	}

	// Ensure config.Project exists on the Jira server
	allProjects, response, err := jiraClient.Project.GetList()
	if err != nil {
		fmt.Println(err.Error())
		body, decodingErr := ioutil.ReadAll(response.Body)
		if err != nil {
			fmt.Println(decodingErr.Error())
		}
		fmt.Printf("Error response from Jira when retrieving project list: %+v\n", string(body))
	}
	var projectExists bool
	for _, project := range *allProjects {
		if project.Key == config.Project {
			projectExists = true
			break
		}
	}
	if !projectExists {
		panic(fmt.Sprintf("Project %v does not exist on your Jira server", config.Project))
	}

	// Ensure config.DefaultStatus exists on the Jira server
	allStatuses, response, err := jiraClient.Status.GetAllStatuses()
	if err != nil {
		fmt.Println(err.Error())
		body, decodingErr := ioutil.ReadAll(response.Body)
		if err != nil {
			fmt.Println(decodingErr.Error())
		}
		fmt.Printf("Error response from Jira when retrieving status list: %+v\n", string(body))
	}
	var statusExists bool
	for _, status := range allStatuses {
		if status.Name == config.DefaultStatus {
			statusExists = true
			break
		}
	}
	if !statusExists {
		panic(fmt.Sprintf("Status %v does not exist on your Jira server", config.DefaultStatus))
	}

	// http server setup
	http.HandleFunc("/webhook", postWebhook)
	http.HandleFunc("/", getRoot)
	fmt.Printf("Listening on port %v\n", config.Port)
	err = http.ListenAndServe(fmt.Sprintf(":%v", config.Port), nil)
	if errors.Is(err, http.ErrServerClosed) {
		fmt.Printf("server closed\n")
	} else if err != nil {
		fmt.Printf("error starting server: %s\n", err)
		os.Exit(1)
	}
}
