package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"

	jira "github.com/andygrunwald/go-jira"
)

const (
	defaultPort = "8080"
)

var (
	jiraClient  *jira.Client
	jiraProject string
)

// Some fields omitted for simplicity, check out the documentation at https://newreleases.io/webhooks
type NewRelease struct {
	Provider string `json:"provider"`
	Project  string `json:"project"`
	Version  string `json:"version"`
}

func ReleaseToJiraIssue(newRelease NewRelease) jira.Issue {
	return jira.Issue{
		Fields: &jira.IssueFields{
			Description: "Update issue generated by newreleases.io",
			Project: jira.Project{
				Key: jiraProject,
			},
			Type: jira.IssueType{
				Name: "Task",
			},
			Summary: fmt.Sprintf("Update %v to version %v", newRelease.Project, newRelease.Version),
		},
	}
}

func getRoot(w http.ResponseWriter, r *http.Request) {
	fmt.Printf("got / request\n")
	io.WriteString(w, "Pong!\n")
}

func postWebhook(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
	}
	// parse newreleases.io webhook
	decoder := json.NewDecoder(r.Body)
	var newRelease NewRelease
	err := decoder.Decode(&newRelease)
	if err != nil {
		http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)
		fmt.Fprintf(os.Stderr, "Couldn't decode body to json: %v\n error: %v\n", r.Body, err)
	}
	fmt.Println(newRelease)

	// create jira ticket
	i := ReleaseToJiraIssue(newRelease)
	issue, response, err := jiraClient.Issue.Create(&i)
	if err != nil {
		fmt.Printf("%+v\n", err)
		body, _ := ioutil.ReadAll(response.Body)
		fmt.Printf("Error response from Jira: %+v\n", string(body))
		http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)

	}
	fmt.Printf("Created issue %v\n", issue.ID)
}

func main() {
	// jira setup
	jiraUrl, jiraUrlPresent := os.LookupEnv("JIRA_URL")
	jiraUser, jiraUserPresent := os.LookupEnv("JIRA_USER")
	jiraToken, jiraTokenPresent := os.LookupEnv("JIRA_TOKEN")
	var jiraProjectPresent bool
	jiraProject, jiraProjectPresent = os.LookupEnv("JIRA_PROJECT")
	if !(jiraUserPresent && jiraTokenPresent && jiraUrlPresent && jiraProjectPresent) {
		fmt.Printf("Missing jira environment variables.\nJIRA_URL present: %v\nJIRA_USER present: %v\nJIRA_TOKEN present: %v\nJIRA_PROJECT present: %v\n",
			jiraUrlPresent, jiraTokenPresent, jiraUserPresent, jiraProjectPresent)
		return
	}

	fmt.Printf("Jira URL: %v\n", jiraUrl)
	tp := jira.BasicAuthTransport{
		Username: jiraUser,
		Password: jiraToken,
	}

	var err error
	jiraClient, err = jira.NewClient(tp.Client(), jiraUrl)
	if err != nil {
		panic(err)
	}

	// http server setup
	port, portPresent := os.LookupEnv("PORT")
	if !portPresent {
		port = defaultPort
		fmt.Printf("No port specified, defaulting to %v\n", defaultPort)
	}

	http.HandleFunc("/webhook", postWebhook)
	http.HandleFunc("/", getRoot)
	fmt.Printf("Listening on port %v\n", port)
	err = http.ListenAndServe(fmt.Sprintf(":%v", port), nil)
	if errors.Is(err, http.ErrServerClosed) {
		fmt.Printf("server closed\n")
	} else if err != nil {
		fmt.Printf("error starting server: %s\n", err)
		os.Exit(1)
	}
}
