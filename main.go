package main

import (
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	jira "github.com/andygrunwald/go-jira"
	"github.com/joho/godotenv"
	"github.com/kelseyhightower/envconfig"
)

var (
	jiraClient *jira.Client
	config     Config
	logger     *log.Logger
)

// Config contains configuration values from environment and .env file.
// Environment takes precedence over the .env file in case of conflicts.
type Config struct {
	// connection and auth
	AuthType       string `envconfig:"AUTH_TYPE" required:"true"`
	JiraToken      string `envconfig:"JIRA_TOKEN" required:"true"`
	JiraUrl        string `envconfig:"JIRA_URL" required:"true"`
	JiraUser       string `envconfig:"JIRA_USER" required:"true"`
	Port           string `envconfig:"PORT" default:"8080"`
	SkipCertVerify bool   `envconfig:"INSECURE_SKIP_CERT_VERIFY" default:"false"`

	// ticket creation
	AddLabels        []string `envconfig:"ADD_LABELS"`
	DefaultStatus    string   `envconfig:"DEFAULT_STATUS" required:"true"`
	DryRun           bool     `envconfig:"DRY_RUN" default:"false"`
	IssueDescription string   `envconfig:"ISSUE_DESCRIPTION" default:"Update issue generated by https://github.2rioffice.com/platform/jelease using newreleases.io"`
	Project          string   `envconfig:"PROJECT" required:"true"`
}

// Release object unmarshaled from the newreleases.io webhook.
// Some fields omitted for simplicity, refer to the documentation at https://newreleases.io/webhooks
type Release struct {
	Provider string `json:"provider"`
	Project  string `json:"project"`
	Version  string `json:"version"`
}

// Generates a Textual summary for the release, intended to be used as the Jira issue summary
func (r Release) IssueSummary() string {
	return fmt.Sprintf("Update %v to version %v", r.Project, r.Version)
}

func (r Release) JiraIssue() jira.Issue {
	labels := append(config.AddLabels, r.Project)
	return jira.Issue{
		Fields: &jira.IssueFields{
			Description: config.IssueDescription,
			Project: jira.Project{
				Key: config.Project,
			},
			Type: jira.IssueType{
				Name: "Task",
			},
			Status: &jira.Status{
				Name: config.DefaultStatus,
			},
			Labels:  labels,
			Summary: r.IssueSummary(),
		},
	}
}

// handleGetRoot handles to GET requests for a basic reachability check
func handleGetRoot(w http.ResponseWriter, r *http.Request) {
	io.WriteString(w, "Ok")
}

// handlePostWebhook handles newreleases.io webhook post requests
func handlePostWebhook(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
		logger.Printf("Rejected request because: %v %v. Attempted method: %v",
			http.StatusMethodNotAllowed, http.StatusText(http.StatusMethodNotAllowed), r.Method)
		return
	}
	// parse newreleases.io webhook
	decoder := json.NewDecoder(r.Body)
	var release Release
	err := decoder.Decode(&release)
	if err != nil {
		http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)
		logger.Printf("failed to decode request body to json with error: %v\n", err)
		return
	}

	// look for existing update tickets
	existingIssuesQuery := fmt.Sprintf("status = %q and labels = %q", config.DefaultStatus, release.Project)
	existingIssues, resp, err := jiraClient.Issue.Search(existingIssuesQuery, &jira.SearchOptions{})
	if err != nil {
		errCtx := errors.New("error response from Jira when searching previous issues")
		if resp != nil {
			body, readErr := io.ReadAll(resp.Body)
			if readErr != nil {
				logger.Println(fmt.Errorf("%v: %w. Failed to decode response body: %v", errCtx, err, readErr).Error())
			} else {
				logger.Println(fmt.Errorf("%v: %w. Response body: %v", errCtx, err, string(body)).Error())
			}
		}
		logger.Println(fmt.Errorf("%v: %w", errCtx, err))
		http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		return
	}

	if len(existingIssues) == 0 {
		// no previous issues, create new jira issue
		i := release.JiraIssue()
		if config.DryRun {
			logger.Printf("skipping creation of issue because Config.DryRun is enabled. Would've created issue: %v", i.Fields.Summary)
			return
		}
		newIssue, response, err := jiraClient.Issue.Create(&i)
		if err != nil {
			errCtx := errors.New("error response from Jira when creating issue")
			if resp != nil {
				body, readErr := io.ReadAll(response.Body)
				if readErr != nil {
					logger.Printf("%v: %v. Failed to decode response body: %v", errCtx, err, readErr)
				} else {
					logger.Printf("%v: %v. Response body: %v", errCtx, err, string(body))
				}
			}
			logger.Println(fmt.Errorf("%v: %w", errCtx, err))
			http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		}
		logger.Printf("Created issue %v\n", newIssue.ID)
		return
	}

	// in case of duplicate issues, update the oldest (probably original) one, ignore rest as duplicates
	var oldestExistingIssue jira.Issue
	var duplicateIssueKeys []string
	for i, existingIssue := range existingIssues {
		if i == 0 {
			oldestExistingIssue = existingIssue
			continue
		}
		tCurrent := time.Time(existingIssue.Fields.Created)
		tOldest := time.Time(oldestExistingIssue.Fields.Created)
		if tCurrent.Before(tOldest) {
			duplicateIssueKeys = append(duplicateIssueKeys, oldestExistingIssue.Key)
			oldestExistingIssue = existingIssue
		} else {
			duplicateIssueKeys = append(duplicateIssueKeys, existingIssue.Key)
		}
	}
	if len(duplicateIssueKeys) > 0 {
		logger.Printf("Ignoring the following possible duplicate issues in favor of older issue %v: %v", oldestExistingIssue.Key,
			strings.Join(duplicateIssueKeys, ", "))
	}

	// This seems hacky, but is taken from the official examples
	// https://github.com/andygrunwald/go-jira/blob/47d27a76e84da43f6e27e1cd0f930e6763dc79d7/examples/addlabel/main.go
	// There is also a jiraClient.Issue.Update() method, but it panics and does not provide a usage example
	type summaryUpdate struct {
		Set string `json:"set" structs:"set"`
	}
	type issueUpdate struct {
		Summary []summaryUpdate `json:"summary" structs:"summary"`
	}
	previousSummary := oldestExistingIssue.Fields.Summary
	if config.DryRun {
		logger.Printf("skipping update of issue because Config.DryRun is enabled. Would've updated issue %v with new summary %q", oldestExistingIssue.Key, release.IssueSummary())
		return
	}
	updates := map[string]any{
		"update": issueUpdate{
			Summary: []summaryUpdate{
				{Set: release.IssueSummary()},
			},
		},
	}
	resp, err = jiraClient.Issue.UpdateIssue(oldestExistingIssue.ID, updates)
	if err != nil {
		errCtx := errors.New("error response from Jira when updating issue")
		if resp != nil {
			body, readErr := io.ReadAll(resp.Body)
			if readErr != nil {
				logger.Printf("%v: %v. Failed to decode response body: %v", errCtx, err, readErr)
			} else {
				logger.Printf("%v: %v. Response body: %v", errCtx, err, string(body))
			}
		}
		logger.Println(fmt.Errorf("%v: %w", errCtx, err))
		http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		return
	}
	logger.Printf("Updated issue summary from %q to %q", previousSummary, release.IssueSummary())
}

func configSetup() error {
	err := godotenv.Load()
	if err != nil {
		logger.Println("No .env file found.")
	}

	err = envconfig.Process("jelease", &config)
	if err != nil {
		return err
	}

	logger.Printf("Jira URL: %v\n", config.JiraUrl)

	var httpClient *http.Client
	tlsConfig := tls.Config{InsecureSkipVerify: config.SkipCertVerify}

	switch strings.ToLower(config.AuthType) {
	case "pat":
		httpClient = (&jira.PATAuthTransport{
			Token:     config.JiraToken,
			Transport: &http.Transport{TLSClientConfig: &tlsConfig},
		}).Client()
	case "token":
		httpClient = (&jira.BasicAuthTransport{
			Username:  config.JiraUser,
			Password:  config.JiraToken,
			Transport: &http.Transport{TLSClientConfig: &tlsConfig},
		}).Client()
	default:
		return fmt.Errorf("invalid AUTH_TYPE value %q. Has to be one of [pat, token]", config.AuthType)
	}
	httpClient.Timeout = 10 * time.Second
	jiraClient, err = jira.NewClient(httpClient, config.JiraUrl)
	if err != nil {
		return fmt.Errorf("failed to create jira client: %w", err)
	}

	return nil
}

func projectExists() error {
	allProjects, response, err := jiraClient.Project.GetList()
	if err != nil {
		errCtx := errors.New("error response from Jira when retrieving project list")
		if response != nil {
			body, readErr := io.ReadAll(response.Body)
			if readErr != nil {
				return fmt.Errorf("%v: %w. Failed to decode response body: %v", errCtx, err, readErr)
			}
			return fmt.Errorf("%v: %w. Response body: %v", errCtx, err, string(body))
		}
		return fmt.Errorf("%v: %w", errCtx, err)
	}
	var projectExists bool
	for _, project := range *allProjects {
		if project.Key == config.Project {
			projectExists = true
			break
		}
	}
	if !projectExists {
		return fmt.Errorf("project %v does not exist on your Jira server", config.Project)
	}
	return nil
}

func statusExists() error {
	allStatuses, response, err := jiraClient.Status.GetAllStatuses()
	if err != nil {
		errCtx := errors.New("error response from Jira when retrieving status list: %+v")
		if response != nil {
			body, readErr := io.ReadAll(response.Body)
			if readErr != nil {
				return fmt.Errorf("%v: %w. Failed to decode response body: %v", errCtx, err, readErr)
			}
			return fmt.Errorf("%v: %w. Response body: %v", errCtx, err, string(body))
		}
		return fmt.Errorf("%v: %w", errCtx, err)
	}
	var statusExists bool
	for _, status := range allStatuses {
		if status.Name == config.DefaultStatus {
			statusExists = true
			break
		}
	}
	if !statusExists {
		var statusSB strings.Builder
		for i, status := range allStatuses {
			if i > 0 {
				statusSB.WriteString(", ")
			}
			statusSB.WriteString(status.Name)
		}
		return fmt.Errorf("status %q does not exist on your Jira server for project %q. Available statuses: [%v]", config.DefaultStatus, config.Project, statusSB.String())
	}
	return nil
}

func serveHTTP() error {
	http.HandleFunc("/webhook", handlePostWebhook)
	http.HandleFunc("/", handleGetRoot)
	logger.Printf("Listening on port %v\n", config.Port)
	return http.ListenAndServe(fmt.Sprintf(":%v", config.Port), nil)
}

func init() {
	logger = log.New(os.Stderr, "", log.LstdFlags|log.Lshortfile)
}

func main() {
	err := run()
	if errors.Is(err, http.ErrServerClosed) {
		logger.Println("server closed")
	} else if err != nil {
		logger.Println(err.Error())
		os.Exit(1)
	}
}

func run() error {

	err := configSetup()
	if err != nil {
		return fmt.Errorf("error in config setup: %w", err)
	}
	err = projectExists()
	if err != nil {
		return fmt.Errorf("error in check if configured project exists: %w", err)
	}
	logger.Printf("Configured project %q found ✓\n", config.Project)
	err = statusExists()
	if err != nil {
		return fmt.Errorf("error in check if configured default status exists: %w", err)
	}
	logger.Printf("Configured default status %q found ✓\n", config.DefaultStatus)
	return serveHTTP()
}
