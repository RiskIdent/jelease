package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"

	jira "github.com/andygrunwald/go-jira"
	"github.com/joho/godotenv"
	"github.com/kelseyhightower/envconfig"
)

var (
	jiraClient *jira.Client
	config     Config
)

// Configuration read from environment or .env file
type Config struct {
	// Consider: add split_words tag for nicer readability of env vars
	Port        string `default:"8080"`
	JiraUrl     string `required:"true"`
	JiraUser    string `required:"true"`
	JiraToken   string `required:"true"`
	JiraProject string `required:"true"`
	AddLabels   []string
}

// A new release object unmarshaled from the newreleases.io webhook.
// Some fields omitted for simplicity, check out the documentation at https://newreleases.io/webhooks
type NewRelease struct {
	Provider string `json:"provider"`
	Project  string `json:"project"`
	Version  string `json:"version"`
}

func ReleaseToJiraIssue(newRelease NewRelease) jira.Issue {
	labels := append(config.AddLabels, newRelease.Project)
	return jira.Issue{
		Fields: &jira.IssueFields{
			Description: "Update issue generated by newreleases.io",
			Project: jira.Project{
				Key: config.JiraProject,
			},
			Type: jira.IssueType{
				Name: "Task",
			},
			// Status: ,
			Labels:  labels,
			Summary: fmt.Sprintf("Update %v to version %v", newRelease.Project, newRelease.Version),
		},
	}
}

func getRoot(w http.ResponseWriter, r *http.Request) {
	fmt.Printf("got / request\n")
	io.WriteString(w, "Pong!\n")
}

func postWebhook(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
	}
	// parse newreleases.io webhook
	decoder := json.NewDecoder(r.Body)
	var newRelease NewRelease
	err := decoder.Decode(&newRelease)
	if err != nil {
		http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)
		fmt.Fprintf(os.Stderr, "Couldn't decode body to json: %v\n error: %v\n", r.Body, err)
	}
	fmt.Println(newRelease)

	// look for existing releases

	// create jira ticket
	i := ReleaseToJiraIssue(newRelease)
	issue, response, err := jiraClient.Issue.Create(&i)
	if err != nil {
		fmt.Printf("%+v\n", err)
		body, _ := ioutil.ReadAll(response.Body)
		fmt.Printf("Error response from Jira: %+v\n", string(body))
		http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)

	}
	fmt.Printf("Created issue %v\n", issue.ID)
}

func main() {
	// configuration setup
	err := godotenv.Load()
	if err != nil {
		fmt.Println("No .env file found.")
	}

	err = envconfig.Process("jelease", &config)
	if err != nil {
		log.Fatal(err.Error())
	}

	fmt.Printf("Jira URL: %v\n", config.JiraUrl)
	tp := jira.BasicAuthTransport{
		Username: config.JiraUser,
		Password: config.JiraToken,
	}

	jiraClient, err = jira.NewClient(tp.Client(), config.JiraUrl)
	if err != nil {
		panic(err)
	}

	// http serversetup
	http.HandleFunc("/webhook", postWebhook)
	http.HandleFunc("/", getRoot)
	fmt.Printf("Listening on port %v\n", config.Port)
	err = http.ListenAndServe(fmt.Sprintf(":%v", config.Port), nil)
	if errors.Is(err, http.ErrServerClosed) {
		fmt.Printf("server closed\n")
	} else if err != nil {
		fmt.Printf("error starting server: %s\n", err)
		os.Exit(1)
	}
}
